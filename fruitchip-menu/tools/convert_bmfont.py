import argparse
import io
from io import StringIO
from pathlib import Path

TYPES = """// generated by convert_bmfont.py

#pragma once

#include <stdint.h>
#include <wchar.h>

typedef struct BMFontChar {
    uint16_t x;
    uint16_t y;
    uint16_t width;
    uint16_t height;
    int16_t xoffset;
    int16_t yoffset;
    int16_t xadvance;
    uint8_t page;
} BMFontChar;

typedef struct BMFontBucket {
    wchar_t startChar;
    wchar_t endChar;
    const BMFontChar *chars;
} BMFontBucket;

typedef struct BMFontPage {
    unsigned int size;
    unsigned char *data;
} BMFontPage;

typedef struct BMFont {
    uint8_t lineHeight;
    uint16_t bucketCount;
    const BMFontBucket *buckets;
    uint16_t pageCount;
    const BMFontPage *pages;
} BMFont;

"""


def peek(fd: StringIO):
    c = fd.read(1)
    pos = fd.tell()
    fd.seek(pos - 1, io.SEEK_SET)
    return c


def skip_characters(fd: StringIO, c: str):
    while True:
        if peek(fd) == c:
            fd.read(1)
        else:
            break


def read_until_character(fd: StringIO, c: str):
    skip_characters(fd, ' ')

    buffer = ''
    while True:
        next_c = peek(fd)
        if next_c == c or next_c == '\r' or next_c == '\n':
            break

        buffer += fd.read(1)

    return buffer


def read_value(fd: StringIO):
    skip_characters(fd, ' ')
    fd.read(1)  # =

    if peek(fd) == '"':
        fd.read(1)
        s = read_until_character(fd, '"')
        fd.read(1)
        return s
    else:
        return read_until_character(fd, ' ')


def parse_fnt(fd: StringIO):
    while True:
        section = read_until_character(fd, ' ')

        kv = {}

        while True:
            k = read_until_character(fd, '=')
            v = read_value(fd)
            kv[k] = v

            eol = peek(fd) == '\r'
            if eol:
                fd.read(1)

            eol |= peek(fd) == '\n'
            if eol:
                fd.read(1)

            if eol:
                break

        yield section, kv

        if peek(fd) == '':  # EOF
            break


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('fnt')
    parser.add_argument('embed_path_root', type=Path)
    parser.add_argument('out_path', type=Path)
    args = parser.parse_args()

    with open(args.fnt, 'r') as h:
        # buffer the data, speeds up the processing
        fd = StringIO(h.read())

        line_height: int = None
        font_name: str = None
        buckets = []
        pages = []

        last_char_id = None
        bucket = None

        for section, kv in parse_fnt(fd):
            if section == 'info':
                font_name = kv['face'].upper().replace(' ', '_')

            if section == 'common':
                line_height = int(kv['lineHeight'])

            elif section == 'page':
                pages.append(kv['file'])

            elif section == 'char':
                char = {
                    'id': int(kv['id']),
                    'x': int(kv['x']),
                    'y': int(kv['y']),
                    'w': int(kv['width']),
                    'h': int(kv['height']),
                    'xoff': int(kv['xoffset']),
                    'yoff': int(kv['yoffset']),
                    'xadv': int(kv['xadvance']),
                    'page': int(kv['page']),
                }

                if font_name == 'HACK':
                    if char['id'] in [9632, 9650, 9679]:  # ■ ▲ ●
                        char['yoff'] -= 1  # lift one pixel up to align with text

                if last_char_id is None or char['id'] != last_char_id + 1:
                    if bucket is not None:
                        buckets.append(bucket)
                    bucket = []

                bucket.append(char)
                last_char_id = char['id']

            elif section == 'kernings':
                raise NotImplementedError

        buckets.append(bucket)

    buckets_idx_text = f'const BMFontBucket {font_name}_BUCKETS[] = {{\n'
    buckets_text = ''
    for bucket in buckets:
        start_char_id = bucket[0]['id']
        end_char_id = bucket[-1]['id']
        name = f'{font_name}_BUCKET_{start_char_id}_TO_{end_char_id}'

        buckets_idx_text += f'    {{{start_char_id}, {end_char_id}, {name}}},\n'

        bucket_text = f'const BMFontChar {name}[] = {{\n'
        for item in bucket:
            bucket_text += f"    {{{item['x']}, {item['y']}, {item['w']}, {item['h']}, {item['xoff']}, {item['yoff']}, {item['xadv']}, {item['page']}}},\n"
        bucket_text += f'}};\n\n'

        buckets_text += bucket_text

    buckets_idx_text += f'}};\n'

    buckets_text += buckets_idx_text

    out_text = TYPES + buckets_text + '\n'

    for i, page_path in enumerate(pages):
        out_text += f'uint8_t {font_name}_PAGE_{i}[] = {{\n'
        out_text += f'    #embed "{args.embed_path_root / page_path}"\n'
        out_text += f'}};\n\n'

    out_text += f'const BMFontPage {font_name}_PAGES[] = {{\n'
    for i, _ in enumerate(pages):
        out_text += f'    {{sizeof({font_name}_PAGE_{i}), {font_name}_PAGE_{i}}},\n'
    out_text += f'}};\n\n'

    out_text += f'const struct BMFont {font_name} = {{\n'
    out_text += f'    .lineHeight = {line_height},\n'
    out_text += f'    .bucketCount = sizeof({font_name}_BUCKETS) / sizeof(*{font_name}_BUCKETS),\n'
    out_text += f'    .buckets = {font_name}_BUCKETS,\n'
    out_text += f'    .pageCount = {len(pages)},\n'
    out_text += f'    .pages = {font_name}_PAGES,\n'
    out_text += f'}};\n'

    args.out_path.parent.mkdir(parents=True, exist_ok=True)
    with open(args.out_path, 'w') as out:
        out.write(out_text)


if __name__ == '__main__':
    main()
