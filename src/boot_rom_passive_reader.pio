.define PUBLIC BOOT_ROM_Q0_PIN 2
.define PUBLIC BOOT_ROM_Q1_PIN 3
.define PUBLIC BOOT_ROM_Q2_PIN 4
.define PUBLIC BOOT_ROM_Q3_PIN 5
.define PUBLIC BOOT_ROM_Q4_PIN 6
.define PUBLIC BOOT_ROM_Q5_PIN 7
.define PUBLIC BOOT_ROM_Q6_PIN 8
.define PUBLIC BOOT_ROM_Q7_PIN 9
.define PUBLIC BOOT_ROM_CE_PIN 10
.define PUBLIC BOOT_ROM_OE_PIN 11

.define PUBLIC BYTE_OUT_IRQ 0
.define PUBLIC DATA_IN_PAUSED_IRQ 4
.define PUBLIC DATA_OUT_PAUSED_IRQ 5

// 1000/240, 4.16ns @ 240 MHz

// sampling period of 10ns
// CE, 130-320ns high, ~810 ns low, ~320ns high
// OE, 360ns high, 130ns low, 80ns high, 130ns low, 80ns high, 130ns low, 80ns high, 130ns low, 360ns high

.program boot_rom_read_sniffer
    wait 0 irq DATA_IN_PAUSED_IRQ
    wait 0 gpio BOOT_ROM_CE_PIN
    wait 0 gpio BOOT_ROM_OE_PIN [5]
    in pins, 8
    wait 1 gpio BOOT_ROM_OE_PIN
// 5 instructions

// watching writes on a ROM, you may ask,
// writing into BOOT ROM area will still result
// in write command being send over the wire,
// IC will reject it, but we can observe it.
// multiple writes one after the other
// will end up holding CE low the entire time.
// ~920ns pulse for one byte (450+-10ns low, 470+-10ns high).
.program boot_rom_write_sniffer
start:
    wait 0 irq DATA_IN_PAUSED_IRQ
    wait 1 gpio BOOT_ROM_CE_PIN
    wait 0 gpio BOOT_ROM_CE_PIN [3] // 12.5 ns @ 240 MHz
    jmp pin oe_high
oe_low:
    // read command, ignore
    jmp start
oe_high:
    in pins, 8
// 6 instructions

.program boot_rom_data_out
start:
    pull ifempty block
    wait 0 irq DATA_OUT_PAUSED_IRQ
    wait 0 gpio BOOT_ROM_OE_PIN
    jmp pin start
    out pins, 8
    wait 1 gpio BOOT_ROM_OE_PIN [10] // match the delay on pindirs switcher, +1 cycle just in case to make sure IRQ is set
    wait 0 irq BYTE_OUT_IRQ
// 7 instructions

// MX29LV320E is probably not the exact chip used by PS2, but it appears to be compatible
.program boot_rom_data_pindirs_switcher
.side_set 1 opt
    mov osr !null
ce_high:
    wait 0 irq DATA_OUT_PAUSED_IRQ
    wait 0 gpio BOOT_ROM_OE_PIN
    jmp pin ce_high
    out pindirs, 8 side 1           // set OUT (Q0-Q7) to 1 (output), SIDE (LED) to 1 (on)
    mov osr null
    wait 1 gpio BOOT_ROM_OE_PIN [7] // hold the data for a bit after rising edge
    out pindirs, 8 side 0           // set OUT (Q0-Q7) to 0 (high impedance), SIDE to 0 (off)
    irq wait BYTE_OUT_IRQ
    // 9 instructions


// 27 used, 5 remaining

% c-sdk {
static inline void boot_rom_pio_gpio_init(PIO pio) {
    pio_gpio_init(pio, BOOT_ROM_Q0_PIN);
    pio_gpio_init(pio, BOOT_ROM_Q1_PIN);
    pio_gpio_init(pio, BOOT_ROM_Q2_PIN);
    pio_gpio_init(pio, BOOT_ROM_Q3_PIN);
    pio_gpio_init(pio, BOOT_ROM_Q4_PIN);
    pio_gpio_init(pio, BOOT_ROM_Q5_PIN);
    pio_gpio_init(pio, BOOT_ROM_Q6_PIN);
    pio_gpio_init(pio, BOOT_ROM_Q7_PIN);
    pio_gpio_init(pio, BOOT_ROM_CE_PIN);
    pio_gpio_init(pio, BOOT_ROM_OE_PIN);
}

static inline void boot_rom_read_sniffer_init_and_start(PIO pio, uint sm, uint offset) {
    boot_rom_pio_gpio_init(pio);

    pio_sm_config cfg = boot_rom_read_sniffer_program_get_default_config(offset);

    sm_config_set_in_pins(&cfg, BOOT_ROM_Q0_PIN);
    pio_sm_set_consecutive_pindirs(pio, sm, BOOT_ROM_Q0_PIN, 8 + 2, false); // set all pins to input

    sm_config_set_jmp_pin(&cfg, BOOT_ROM_CE_PIN);

    sm_config_set_in_shift(&cfg, false, true, 8); /* shift ISR to left, autopush every 8 bits */
    sm_config_set_fifo_join(&cfg, PIO_FIFO_JOIN_RX);

    pio_sm_init(pio, sm, offset, &cfg);
    pio_sm_set_enabled(pio, sm, true);
}

static inline void boot_rom_write_sniffer_init_and_start(PIO pio, uint sm, uint offset) {
    boot_rom_pio_gpio_init(pio);

    pio_sm_config cfg = boot_rom_write_sniffer_program_get_default_config(offset);

    sm_config_set_in_pins(&cfg, BOOT_ROM_Q0_PIN);
    pio_sm_set_consecutive_pindirs(pio, sm, BOOT_ROM_Q0_PIN, 8 + 2, false); // set all pins to input

    sm_config_set_jmp_pin(&cfg, BOOT_ROM_OE_PIN);

    sm_config_set_in_shift(&cfg, false, true, 8); /* shift ISR to left, autopush every 8 bits */
    sm_config_set_fifo_join(&cfg, PIO_FIFO_JOIN_RX);

    pio_sm_init(pio, sm, offset, &cfg);
    pio_sm_set_enabled(pio, sm, true);
}

static inline void boot_rom_data_pindirs_switcher_init_and_start(PIO pio, uint sm, uint offset) {
    boot_rom_pio_gpio_init(pio);

    pio_sm_config cfg = boot_rom_data_pindirs_switcher_program_get_default_config(offset);

    sm_config_set_out_pins(&cfg, BOOT_ROM_Q0_PIN, 8);
    pio_sm_set_consecutive_pindirs(pio, sm, BOOT_ROM_Q0_PIN, 8, GPIO_IN);

    // set LED pin as side pin to flash read activity
    pio_gpio_init(pio, PICO_DEFAULT_LED_PIN);
    sm_config_set_sideset_pin_base(&cfg, PICO_DEFAULT_LED_PIN);
    pio_sm_set_consecutive_pindirs(pio, sm, PICO_DEFAULT_LED_PIN, 1, GPIO_OUT);

    // set CE and OE pins to input
    sm_config_set_jmp_pin(&cfg, BOOT_ROM_CE_PIN);
    pio_sm_set_consecutive_pindirs(pio, sm, BOOT_ROM_CE_PIN, 1, GPIO_IN);
    pio_sm_set_consecutive_pindirs(pio, sm, BOOT_ROM_OE_PIN, 1, GPIO_IN);

    sm_config_set_out_shift(&cfg, true, true, 8); /* shift OSR to left, autopull every 8 bits */
    sm_config_set_fifo_join(&cfg, PIO_FIFO_JOIN_TX);

    pio_sm_init(pio, sm, offset, &cfg);
    pio_sm_set_enabled(pio, sm, true);
}

static inline void boot_rom_data_out_init_and_start(PIO pio, uint sm, uint offset) {
    boot_rom_pio_gpio_init(pio);

    pio_sm_config cfg = boot_rom_data_out_program_get_default_config(offset);

    sm_config_set_out_pins(&cfg, BOOT_ROM_Q0_PIN, 8);
    // start data pins in input, `boot_rom_data_pindirs_switcher` will switch direction as needed
    pio_sm_set_consecutive_pindirs(pio, sm, BOOT_ROM_Q0_PIN, 8, false);
    // set sticky output, we need to hold data until rising edge
    sm_config_set_out_special(&cfg, true, false, false);

    sm_config_set_jmp_pin(&cfg, BOOT_ROM_CE_PIN);

    // set CE and OE pins to input
    pio_sm_set_consecutive_pindirs(pio, sm, BOOT_ROM_CE_PIN, 1, false);
    pio_sm_set_consecutive_pindirs(pio, sm, BOOT_ROM_OE_PIN, 1, false);

    sm_config_set_out_shift(&cfg, true, false, 8); /* shift OSR to left, no autopull, 8 bits threshold */
    sm_config_set_fifo_join(&cfg, PIO_FIFO_JOIN_TX);

    pio_sm_init(pio, sm, offset, &cfg);
    pio_sm_set_enabled(pio, sm, true);
}
%}